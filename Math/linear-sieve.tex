\subsection{线性筛}
factor 为最小质因子；
mu 为莫比乌斯函数；
phi 为欧拉函数；
e 为质因子最高次幂，d 为因数个数；
f 为因数和，g 为最小质因子的幂和，即 $p + p^{1} + p^{2} + \cdots + p^{k}$ 。
理论上积性函数都可以线性筛。

\begin{lstlisting}
const int MAXN = 1e7 + 5;
bitset<MAXN> vis;
int prime[MAXN / 15], prime_cnt;
int factor[MAXN], e[MAXN], d[MAXN], mu[MAXN], phi[MAXN];
void sieve() {
  factor[1] = 1, e[1] = 0, d[1] = 1, mu[1] = 1, phi[1] = 1;
  for (int i = 2; i < MAXN; ++i) {
    if (!vis[i]) {
      prime[prime_cnt++] = i;
      factor[i] = i;
      mu[i] = -1, phi[i] = i - 1;
      e[i] = 1, d[i] = 2;
      g[i] = f[i] = i + 1;
    }
    for (int j = 0, t; j < prime_cnt && (t = i * prime[j]) < MAXN; ++j) {
      vis[t] = 1;
      factor[t] = prime[j];
      if (i % prime[j] == 0) {
        mu[t] = 0, phi[t] = phi[i] * prime[j];
        e[t] = e[i] + 1, d[t] = d[i] / e[t] * (e[t] + 1);
        g[t] = g[i] * prime[j] + 1, f[t] = f[i] / g[i] * g[t];
        break;
      } else {
        mu[t] = -mu[i], phi[t] = phi[i] * (prime[j] - 1);
        e[t] = 1, d[t] = d[i] * 2;
        g[t] = 1 + prime[j], f[t] = f[i] * f[prime[j]];
      }
    }
  }
}
\end{lstlisting}